- [Pending](#pending)
- [Statically typed and Dynamically Typed Languages](#statically-typed-and-dynamically-typed-languages)
- [LLVM](#llvm)
- [Hygienic Macros](#hygienic-macros)
- [Imperative \& Functional Language](#imperative--functional-language)
- [Type Safety](#type-safety)
- [Metaprogramming](#metaprogramming)
- [Functional Programming](#functional-programming)

### Pending
* [ ] Double Free
* [ ] Use After Free
* [ ] Iterator invalidation
* [ ] Integer Overflow
* [ ] FFI 

### Statically typed and Dynamically Typed Languages

*   A statically typed language is one where the data type of a variable is checked and verified at compile time.

* Key characteristics of statically typed languages:
    * **Type declaration**: You explicitly declare the data type of a variable when you define it.   
    * **Type checking**: The compiler verifies that you're using variables correctly based on their declared types.   
    * **Early error detection**: Many potential errors are caught during compilation, leading to more reliable code.   
    * **Improved performance**: Due to early type checking, the compiler can often optimize code better.

* Examples of statically typed languages - Java, C++, C#, Rust, Go, Swift

* In contrast to dynamically typed languages, where type checking happens at runtime, static typing offers a higher level of safety and predictability.

### LLVM

* LLVM is a collection of modular and reusable compiler and toolchain technologies. Think of it as a powerful toolkit for building compilers.

* Core Components
    * **Intermediate Representation (IR)**: This is a low-level language-independent representation of code. It's like a common ground for different programming languages.
    * **Optimizer**: LLVM includes various optimization passes to improve code performance and efficiency.
    * **Code Generator**: It translates the optimized IR into machine code for specific architectures.

* Key Features
    * **Portability**: LLVM can target multiple architectures, making it suitable for cross-platform development.
    * **Flexibility**: It can be used for both static and dynamic compilation.
    * **Efficiency**: Its optimization capabilities lead to high-performance code generation.
    * **Modularity**: Its components can be easily combined and customized.

### Hygienic Macros

* Hygienic macros prevent variable capture by ensuring that the names generated within a macro are unique and don't clash with existing names. 
* This is achieved through a process called alpha-renaming, where the macro system automatically renames variables to avoid conflicts. 
* Rust provides a powerful macro system with hygiene guarantees.
* Example

    * Code Block
        ```
        let x = 5
        repeat(3) {
            print(x)  // Intended to print 5 three times
        }
        ```
    
    * Non-Hygienic Macro
        ```
        for i in range(3):
        print(x)
        ```
    
    * Hygienic Macro
        ```
        for i in range(3):
        print(x_1)  // x_1 is a fresh variable generated by the macro
        ```

### Imperative & Functional Language

* **Imperative**: Focuses on steps to achieve the result, using mutable variables and loops.
* **Functional**: Focuses on defining the problem (factorial calculation) using recursion and pure functions.
* The functional approach often leads to more concise and potentially more efficient code, especially for problems that can be naturally expressed recursively.
* Rust is not a functional language but uses functional concepts.


### Type Safety

* Type safety is a language feature that prevents type errors by ensuring that data is used in appropriate ways. 
* It's essentially the compiler or interpreter's way of checking that you're not trying to mix apples and oranges.

* How it works
    * **Type declaration**: You specify the data type of a variable when you declare it.   
    * **Type checking**: The compiler or interpreter verifies that operations performed on variables are compatible with their declared types.

* Python is a dynamically typed language, while C++ and Rust are statically typed.
* In languages like C, type safety is weaker. You can cast data to different types, potentially leading to runtime errors if the cast is invalid. 

### Metaprogramming
* Metaprogramming is a programming technique where a program can manipulate or generate other programs as its data. 
* In essence, it's code that writes code.
* **Examples**:
    * **Macros**: Language constructs that allow code generation at compile time (e.g., Rust, Lisp).
    * **Templates:** Parametric polymorphism in languages like C++ for code generation based on types.
    * Reflection: The ability of a program to inspect its own structure at runtime (e.g., Java, Python).
    * Code Generation: Creating new code based on specific requirements or patterns.   

### Functional Programming
* Functional programming is a programming paradigm that emphasizes the evaluation of expressions rather than statements. 
* It treats computation as the evaluation of mathematical functions and avoids changing state and mutable data.

* **Characteristics:**
  *   **Pure functions:** Functions that always produce the same output for the same input and have no side effects.
  *   **Immutability:** Data is treated as immutable, meaning it cannot be changed after it's created.
  *   **Higher-order functions:** Functions that can take other functions as arguments or return functions as results.
  *   **Recursion:** Functions that call themselves to solve problems, often used to replace loops.
  *   **Lazy evaluation:** Expressions are evaluated only when their results are needed.


* **Benefits:**
  *   Improved code readability and maintainability: Functional code is often easier to understand and modify due to its declarative nature.
  *   **Reduced bugs:** The lack of mutable state and side effects can help prevent common programming errors.
  *   **Parallelism:** Functional programs can be more easily parallelized, as pure functions can be executed independently.
  *   **Better testing:** Functional tests can be simpler to write and maintain due to the deterministic nature of pure functions.